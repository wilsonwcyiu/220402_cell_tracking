# -*- coding: utf-8 -*-
"""Lineage_methods_Viterbi_visualize.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZAMApLe-8OPQt3EC0MwOK5r3EcYe_a-d
"""

# from google.colab import drive
import os
from collections import defaultdict
from multiprocessing.pool import ThreadPool
from os import listdir
from os.path import join, basename
import numpy as np
from skimage import measure, filters
import matplotlib.pyplot as plt
from matplotlib import cm
from scipy.optimize import linear_sum_assignment
import copy
import time
import cv2
# from google.colab.patches import cv2_imshow
import random
from itertools import combinations
import pickle

ROOT = '/content/drive/'     # default for the drive
# drive.mount(ROOT)           # we mount the drive at /content/drive

# PROJECT_PATH = '/content/drive/MyDrive'

"""# 新段落"""

def main():
    folder_path: str = 'D:/viterbi linkage/dataset/'

    segmentation_folder = folder_path + 'segmentation_unet_seg//'
    save_dir = folder_path + '/save_directory_enhancement/'
    video_folder_name = folder_path + '/save_directory_enhancement/trajectory_result_video/'
    pkl_file_name: str = "ground_truth_results_dict.pkl"
    abs_save_dir = save_dir + "track_data_from_pkl/" + pkl_file_name.replace(".pkl", "")


    #settings
    track_length: int = 30
    is_save_result = True

    to_generate_series_list: list = ['S01', 'S02', 'S03', 'S04', 'S05', 'S06', 'S07', 'S08', 'S09', 'S10',
                                     'S11', 'S12', 'S13', 'S14', 'S15', 'S16', 'S17', 'S18', 'S19', 'S20']

    start_time = time.perf_counter()

    series_viterbi_result_list_dict: dict = open_track_dictionary(save_dir + pkl_file_name)




    # if pkl_file_name == "hungarian_adj_results_dict.pkl":
    #     tmp_track_tuple_list_dict = defaultdict(list)
    #     for series, track_array in series_viterbi_result_list_dict.items():
    #         track_tuple_list = track_array.tolist()
    #         tmp_track_tuple_list_dict[series] = track_tuple_list
    #
    #     series_viterbi_result_list_dict = tmp_track_tuple_list_dict


    ground_truth_cell_dict = obtain_ground_truth_cell_dict()
    for series in to_generate_series_list:
        ground_truth_cell_list = ground_truth_cell_dict[series]
        print("=============" + series + "==================")
        for cell_track_list in series_viterbi_result_list_dict[series]:
            is_in_gt_file = (cell_track_list[0] in ground_truth_cell_list)
            if is_in_gt_file:
                print(cell_track_list)

        print("\n")



    with open(abs_save_dir + ".txt", 'w') as f:
        f.write(f"Execution time: ---- seconds\n")
        # f.write("hyper_para--- ID: " + str(idx+1) + "; \n" + hyper_para.__str_newlines__())
        f.write("\n")
        for series in to_generate_series_list:
            f.write("======================" + str(series) + "================================")
            f.write("\n")

            cell_track_list_list = sorted(series_viterbi_result_list_dict[series])
            for cell_track_list in cell_track_list_list:
                # for cell_track_list in viterbi_result_dict[series]:
                f.write(str(cell_track_list))
                f.write("\n")

            f.write("\n\n")




    for series, track_tuple_list_list in series_viterbi_result_list_dict.items():
        ground_truth_cell_list = ground_truth_cell_dict[series]
        track_tuple_list_list = sorted(track_tuple_list_list)
        for track_tuple_list in track_tuple_list_list:
            cell_id = track_tuple_list[0]
            is_in_gt_file = (cell_id in ground_truth_cell_list)
            if is_in_gt_file:
                print(f"series_cell_id_track_dict_dict[\"{series}\"][{cell_id}] = {track_tuple_list}")


    execution_time = time.perf_counter() - start_time
    print(f"Execution time: {execution_time: 0.4f} seconds")



'''opening a track dictionary from file'''
def open_track_dictionary(save_file):
    pickle_in = open(save_file, "rb")
    dictionary = pickle.load(pickle_in)

    return dictionary




if __name__ == '__main__':
    main()